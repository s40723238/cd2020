<h1>Week1~9</h1>
<p>week1</p>
<p>創建倉儲</p>
<p>1.在自己的guthub上新增倉儲</p>
<p>2.將自己倉儲設定底下的github page將sourse改成master branch</p>
<p>3.git clone自己的倉儲</p>
<p>4.在cd2020打git submodule add <a href="https://github.com/mdecourse/cmsimde.git取得">https://github.com/mdecourse/cmsimde.git</a> 取得</p>
<p>cmsimde的資料夾</p>
<p>5.在cmsimde/up_dir複製所有資料貼到cd2020底下</p>
<p>6.回到cd2020並add/commit/push打自己的帳號密碼就完成創建網站了</p>
<p>week2</p>
<p>更新可攜系統</p>
<p>1.在隨身碟創建data的資料夾</p>
<p>2.創建py382資料夾，下載python3.8.2，安裝時將pip的選項取消</p>
<p>3.創建msys64資料夾，下載msys2</p>
<p>4.下載<span>PortableGit到data底下</span></p>
<p><span>5.創wscite432資料夾，下載SciTE</span></p>
<p><span>6.打開SciTE，輸入</span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">@echo off
set Disk=y
subst %Disk%: "data"
 
%Disk%:
 
set HomePath=%Disk%:\home
set HomeDrive=%Disk%:\home
set Home=%Disk%:\home
set USERPROFILE=%Disk%:\home
 
REM 將系統 Python 程式的 io 設為 utf-8
set PYTHONIOENCODING="utf-8"
 
#REM for putty
#Set GIT_HOME=%CDisk%:\portablegit\bin\
#Set GIT_SSH=%Disk%:\putty\plink.exe
 
set PYTHONPATH=%Disk%:\py382\DLLs;%Disk%:\py382\Lib;%Disk%:\py382\Lib\site-packages;
set PYTHONHOME=%Disk%:\py382
 
set path_python=%Disk%:\py382;%Disk%:\py382\Scripts;
set path_msys2=%Disk%:\msys64\mingw64\bin;
set path_git=%Disk%:\portablegit\bin;
set path_tcc=%Disk%:\tcc;
 
path=%Disk%:;%path_python%;%path_msys2%;%path_git%;%path_tcc%;
 
start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe
 
start /MIN %Disk%:\wscite432\wscite\SciTE.exe
start /MIN %Disk%:\wscite432\wscite\SciTE.exe
 
Exit</pre>
<p>另存新檔到隨身碟下，名稱打start.bat</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">@echo off
set Disk=y
path=%PATH%;
 
taskkill /IM python.exe /F
taskkill /IM pythonw.exe /F
taskkill /IM scite.exe /F
 
REM 終止虛擬硬碟與目錄的對應
subst %Disk%: /D
REM 關閉 cmd 指令視窗
taskkill /IM cmd.exe /F
 
EXIT</pre>
<p><span>另存新檔到隨身碟下，名稱打stop.bat，將wscite432資料夾複製一個到y槽</span><br/><br/></p>
<p><span>7.到<a href="https://bootstrap.pypa.io/get-pip.py">網站</a>底下將檔案另存新檔到data底下</span></p>
<p><span>8.打開小黑窗，輸入下載模組的指令</span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">python get-pip.py</pre>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">pip install flask bs4 lxml pelican markdown flask_cors leo</pre>
<p>這樣就完成可攜系統的更新了</p>
<p>w11</p>
<p>1.進入<a href="http://mde.tw/cd2020pj1/content/CMS.html">cd2020pj1</a></p>
<p>2.進入<a href="https://console.developers.google.com">google的api設定網址</a>並登入gm帳號</p>
<p>3.點選建立專案</p>
<p><img alt="" height="338" src="/images/ZoomIt64_bpqLSNy2H0.png" width="600"/></p>
<p>4.git clone <a href="https://github.com/mdecourse/cd2020pj1.git">https://github.com/mdecourse/cd2020pj1.git</a></p>
<p>5.點選api服務再點<span>Google+ Domains API建立</span></p>
<p><span><img alt="" height="338" src="/images/ZoomIt64_XCO1GnCkYZ.png" width="600"/></span></p>
<p><span>6.點憑證<strong></strong><strong></strong>並建立憑證，建立後將用戶端id跟用戶端密碼複製到記事本並存在倉儲資料夾外</span></p>
<p><span>7.設定第一個url:<a href="https://localhost:8443">https://localhost:8443</a>，第二個url:<a href="https://localhost:8443/login/google/按儲存">https://localhost:8443/login/google/按儲存</a></span></p>
<p><span><img alt="" height="338" src="/images/ZoomIt64_cDUqRX9a0g.png" width="600"/></span></p>
<p><span>8.開啟leo，打開cd2020pj1.leo，在@path ./@edit coonfig.py找到第7行key file =...將上下兩個都改成自己剛剛儲存憑證密碼的檔案名稱</span></p>
<p><span><img alt="" height="338" src="/images/ZoomIt64_PguLAGXxC6.png" width="600"/></span></p>
<p><span>9.在小黑窗打pip install authomatic</span></p>
<p><span>10.進入cd2020pj1打python wsgi.py就能開啟近端，畫面長這樣</span></p>
<p><span><img alt="" height="338" src="/images/chrome_RIu31IwMsO.png" width="600"/></span></p>
<p><span></span></p>
<p><span></span></p>
<p><span> </span></p><h1>分組作業</h1>
<p><a href="https://s40723238.github.io/cd2020/content/Assignment1.html">assignment1</a></p>
<p><a href="https://s40723238.github.io/cd2020/content/Assignment2.html">assignment2</a></p>
<h2>Assignment1</h2>
<p>what do you need to know from <a href="http://www.coppeliarobotics.com/helpFiles/index.html" rel="nofollow">http://www.coppeliarobotics.com/helpFiles/index.html</a> <span>to implement a four-wheeled robot?</span></p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/index.html">泡泡龍跟線走</a></p>
<p><a href="https://github.com/s40723238/cd2020/blob/master/downloads/%E5%88%86%E7%B5%84%E4%BB%BB%E5%8B%991.pdf">pdf檔</a></p>
<p>首先開啟教程一的<span>BubbleRob</span>檔案，下圖是接下來的仿真場景。</p>
<p><img alt="" height="335" src="/images/圖1.png" width="517"/></p>
<p>首先創建三個視覺傳感器的第一個，並拖至泡泡龍本體的下方，選擇[Menu bar --&gt; Add --&gt; Vision sensor --&gt; Orthographic type]，並雙擊對話框將對話框內嵾數修改如下:</p>
<p><img alt="" height="615" src="/images/圖2.png" width="396"/></p>
<p>視覺傳感器需面對地面，選擇它，在orientation dialog/orientation tab將數值設定為[180;0;0]。</p>
<p><img alt="" height="44" src="/images/圖4.png" width="44"/>(path edit mode)將視覺傳感器複製並貼上兩次，將名稱改成leftSensor，middleSensor和rightSensor，並將其都拖到泡泡龍本體下。</p>
<p>打開position dialog/position tab,將<span>left sensor設[0.2;0.042;0.018]，</span>middle sensor設[0.2;0;0.018]，right sensor設[0.2;-0.042;0.018]。</p>
<p>現在修改環境，，移去<span>BubbleRob</span>前面的幾個圓柱體，並按[Menu bar --&gt; Add --&gt; Path --&gt; Circle type]在地上加入線，有兩種方法使線形狀改變線路徑</p>
<p>1.點線，crtl加一節點並拖動。</p>
<p>2.點選path edit modle  即可調整</p>
<p>一旦對路徑線條滿意後，雙擊路徑圖案，將Show orientation of points，Show path line和Show current position on path的打勾取消。然後按下Show path shaping dialog，將Path shaping enabled打勾，將type轉到horizontal segment，再將Scaling factor調整為4，最後將顏色調整為黑色，最後還須對路徑作一重要調整，現在路徑的z位置與地板的z位置重合，者樣會使我們有時看到地板，有時看到路徑，為避免此現象，只需將路徑上移0.5即可。</p>
<p>最後一步是調整BubbleRob的控制器，使其也將遵循黑色路徑。 打開附加到bubbleRob的子腳本，並將其替換為以下代碼：</p>
<p>------------------------------</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">function speedChange_callback(ui,id,newVal)
    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100
end

function sysCall_init()
    -- This is executed exactly once, the first time this script is executed
    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self)
    leftMotor=sim.getObjectHandle("leftMotor")
    rightMotor=sim.getObjectHandle("rightMotor")
    noseSensor=sim.getObjectHandle("sensingNose")
    minMaxSpeed={50*math.pi/180,300*math.pi/180}
    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode
    floorSensorHandles={-1,-1,-1}
    floorSensorHandles[1]=sim.getObjectHandle("leftSensor")
    floorSensorHandles[2]=sim.getObjectHandle("middleSensor")
    floorSensorHandles[3]=sim.getObjectHandle("rightSensor")
    -- Create the custom UI:
        xml = '&lt;ui title="'..sim.getObjectName(bubbleRobBase)..' speed" closeable="false" resizeable="false" activate="false"&gt;'..[[
        &lt;hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/&gt;
        &lt;label text="" style="* {margin-left: 300px;}"/&gt;
        &lt;/ui&gt;
        ]]
    ui=simUI.reate(xml)
    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5
    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))
end

function sysCall_actuation()
    result=sim.readProximitySensor(noseSensor)
    if (result&gt;0) then backUntilTime=sim.getSimulationTime()+4 end

    -- read the line detection sensors:
    sensorReading={false,false,false}
    for i=1,3,1 do
        result,data=sim.readVisionSensor(floorSensorHandles[i])
        if (result&gt;=0) then
            sensorReading[i]=(data[11]&lt;0.3) -- data[11] is the average of intensity of the image
        end
        print(sensorReading[i])
    end

    -- compute left and right velocities to follow the detected line:
    rightV=speed
    leftV=speed
    if sensorReading[1] then
        leftV=0.03*speed
    end
    if sensorReading[3] then
        rightV=0.03*speed
    end
    if sensorReading[1] and sensorReading[3] then
        backUntilTime=sim.getSimulationTime()+2
    end

    if (backUntilTime&lt;sim.getSimulationTime()) then
        -- When in forward mode, we simply move forward at the desired speed
        sim.setJointTargetVelocity(leftMotor,leftV)
        sim.setJointTargetVelocity(rightMotor,rightV)
    else
        -- When in backward mode, we simply backup in a curve at reduced speed
        sim.setJointTargetVelocity(leftMotor,-speed/2)
        sim.setJointTargetVelocity(rightMotor,-speed/8)
    end
end

function sysCall_cleanup()
	simUI.destroy(ui)
end</pre>
<pre class="lightRedBox"><br/><br/><br/>------------------------------<br/><br/>現在可以輕鬆地調整視覺感應器的線，選擇一個，按右鍵[Add --&gt; Floating view]然後<br/><br/>在新添加的Floating view跟視覺感應器選起來右鍵[View --&gt; Associate view with selected vision sensor]<br/><br/>最後刪除再教程一的輔助項目，刪除圖像處理視覺傳感器(vision sensor)，該浮動視圖表示障礙物的清除。 通過距<br/>離對話框也刪除距離計算對象。</pre>
<h2>Assignment2</h2>
<p>topic0 p18~p24</p>
<p>以下各節介紹了每種類型的設計過程的詳細特徵以及相關的上下文。</p>
<p>由工業設計師主導概念設計流程</p>
<p><img caption="false" height="341" src="/images/第一張.png" width="590"/></p>
<p>第一階段<span>(Concept Design-I)</span>：工業設計師獨立開發產品的概念，而不受其他部門的干擾。</p>
<p>他們主要關注與美學外觀和用戶體驗有關的方面。 他們很少考慮內部零件，這給了他們很多自由。 他們為外部和高質量渲染圖像生成<span>3D CAD</span>數據以測試該概念。 最終確定外觀形式後，他們會製作一個“設計模型”（一個無功能的原型）來驗證該概念。</p>
<p><span> </span></p>
<p>最後，在“設計評估會議”上選擇最佳設計。此階段的最終結果是外形的<span>3D CAD</span>數據和設計模型。 工程設計師在此階段不採取任何行動。通常，他們甚至不知道工業設計師在設計什麼。</p>
<p><span> </span></p>
<p>第二階段<span>(Product Planning)</span>：產品計劃部門決定所選設計的商業化以及目標市場，設計的目標價格和材料成本。 最後，他們準備了產品計劃文件，並為設計的商業化確定了具體的方向。</p>
<p>第三階段<span>(Concept Design-E/Shape Modification)</span>：前一階段的產品規劃文檔以及由工業設計師開發的最終<span>3D CAD</span>數據是提供給工程設計師的初始輸入。工程設計人員檢查其設計概念的可行性。</p>
<p>工程設計人員會製作實驗性原型，以測試是否可以通過工業設計的外觀形式實現所需的性能。</p>
<p>由於工業設計人員在定義外觀形式時並未考慮內部零件，因此在將內部零件佈置時必會遇到麻煩。</p>
<p>因此，<span>Concept Design-E</span>有一個相應的過程：工業設計師的“形狀修改”。工業設計師使用從工程設計師那裡收到的佈局數據來修改外觀形式。此時，兩個目標相互碰撞。</p>
<p>工業設計師嘗試以保留原始形式，而工程設計人員要求進行修改以確保功能和性能。在這個過程中，發生了非常緊密的交互。結果是有關外部形狀和內部零件佈局的<span>3D CAD</span>數據。</p>
<p>第四階段<span>(Detail design  testing &amp; production/Follow-up)</span>：從這一階段開始，工程設計師在所有零件中領導該過程。 工程設計人員根據上一階段確定的<span>3D CAD</span>數據來決定各個零件的幾何形狀和成分結構。 由於考慮了批量生產或可靠性測試，他們有時會要求工業設計師對外觀設計進行修改。</p>
<p>完成後為了進行詳細設計，我們製作了稱為“工程樣品”的工作原型，以檢查其形式和功能。 在這一點上，工業設計師要評估其外觀設計符合其設計理念的程度。</p>
<p>然後，工程設計師決定供應商，生產模具，並通過多個事件過程測試“生產前原型”，以提高性能的可靠性和產品的耐用性。</p>
<p>另一方面，在“<span>follow-up</span>”中，工業設計師決定如何在產品上應用顏色，圖形，材料和表面處理，並為工程設計師提供相關規範。 對於所生產的每種工作原型，工業設計師都要根據規格測試美學和情感品質。 當他們批准後，他們在設計過程中的正式角色便結束了。 除非獲得批准，否則工程設計師應再次生產和測試有問題的零件。 我們發現所有六個公司都具有這種機制來維持產品的設計質量。</p>
<p>類型<span>1</span>與傳統觀念相反，傳統觀念認為新產品開發過程是通過市場研究或開發新技術來確定市場需求而開始的。 它始於純粹的工業設計師的完全自由的概念化。 這意味著可以根據工業設計師在腦海中設想的圖片來開發新產品。 這與工程設計準則中描述的產品設計流程不一致（例如，在<span>Dym</span>，<span>1994</span>年；<span> Haik</span>＆<span>Shahin</span>，<span>2010</span>年；<span> Pahl</span>等，<span>2007</span>年）中，工業設計人員在概念設計中的作用缺失了。</p>
<p>考慮到相關的理論，即創造力是在以解決方案為導向的方法（<span>Wynn</span>＆<span>Clarkson</span>，<span>2005</span>）對問題進行徹底分析之前發生的，例如“主要生成器”（<span>Darke</span>，<span>1979</span>）和猜想分析模型（<span>Hillier</span>）。 ，<span>Musgrove</span>和<span>O'Sullivan</span>，<span>1972</span>年）以及<span>Lawson</span>（<span>2006</span>年）和<span>March</span>（<span>1984</span>年）的其他相關發現和論點，這將是公司賦予工業設計者自由和自主權以產生創造性解決方案概念的最佳策略。不受外界干擾。實際上，類型<span>1</span>在兩種情況下使用：一種是在形狀和功能上開發新概念產品，包括開發新產品類別（如在公司<span>A</span>和<span>E</span>中），另一種是盡快推出現有產品的新模型（如在公司<span>C</span>中）。當有大量參考設計時，後一種情況似乎是可能的，因此，工業設計師可以在交貨時間短時決定產品尺寸和外部元素而無需任何產品規格。</p>
<p><span>2.2</span>類型<span>2</span>：由工業設計師領導的組合內外流程</p>
<p>公司使用此過程來開發新型產品或修改現有產品。 在任何一種情況下，與類型<span>1</span>不同，產品計劃團隊都將啟動該過程。 我們可以分四個階段來解釋類型<span>2</span>，如下圖所示。</p>
<p><img alt="" height="341" src="/images/第二張.png" width="597"/></p>
<p>第一階段（<span>Product Planning</span>）：產品計劃團隊創建產品計劃文件以啟動產品開發。 它設置了目標市場，目標價格和產品規格。 在開發現有產品的修改版本時，它會根據現有產品（包括競爭對手的產品）做出決定。 在開發新產品時，工程設計師會幫助他們做出決定。 此階段的結果是一個產品計劃文檔。</p>
<p><span> </span></p>
<p>第二階段（<span>(Concept Design-I):</span>）：收到產品計劃部門的產品計劃文件後，工業設計師將決定產品的外觀和相關內部。 他們收集符合產品尺寸和規格的待開發產品所需的功能項目，並從對用戶或設計趨勢的研究中得出形式概念。 然後，他們安排內部零件以決定外觀形式，同時避免內部零件與預期的外部形式之間發生任何衝突。 因此，它們在外形設計和內部零件的佈置之間來回移動。 在此階段，工業設計師和工程設計師之間幾乎沒有互動。 對於最後的事件，設計評估將使用無功能的設計模型進行，因此，此階段的結果是有關產品外觀和初始內部佈局的<span>3D CAD</span>數據以及設計模型。</p>
<p><span> </span></p>
<p>第三階段（<span>Concept Design-E/Shape Modification</span>）：從工業設計師那裡收到<span>3D CAD</span>數據後，工程設計師會密切檢查內部零件與外部形狀有關的可行性和可操作性，並製定最終佈局。 工程設計師檢查它們時，經常要求工業設計師修改佈局或外部形式。 因此，工業設計活動要進行相應的過程。 “形狀修改”。但是，形狀更改不如<span>Type1</span>重大，因為他們在上一階段決定了與內部部件有關的外部形狀。 此階段的結果是有關最終外觀形式和內部零件確定佈局的<span>3D CAD</span>數據。</p>
<p><span> </span></p>
<p>第四階段（<span>Detail design  testing &amp; production/Follow-up</span>）：該階段與類型<span>1</span>並無顯著差異。</p>
<p>類型<span>2</span>的顯著特徵是工業設計師積極參與佈置內部功能組件，同時在第二階段確定外觀形狀。偏重工程設計端。</p>
<p><span> </span></p>
<p><span>2.3</span>類型<span>3</span>：工程設計師主導的內部優先流程</p>
<p><img alt="" height="333" src="/images/第三張.png" width="590"/></p>
<p><span>Type 3</span>與<span>Type 1</span>和<span>Type 2</span>有兩點不同：它們僅用於重新設計現有產品，而工程設計師的活動要先於工業設計師進行。 它要求工程設計師扮演更重要的角色，同時減少工業設計師的角色。 我們解釋它們的特徵如下：</p>
<p><span> </span></p>
<p>第一階段（<span>Product Planning</span>）：如下圖所示，產品計劃團隊首先根據年度產品開發路線圖啟動產品開發項目。 至此，他們在路線圖中確實具有產品的功能概念。 產品規劃專家根據市場上現有的產品確定目標市場，目標價格，產品尺寸和材料成本。 工程設計師經常通過分析競爭對手產品的技術部分並估算材料成本來幫助他們制定產品規格。 此階段的結果是產品計劃文件，其中包括產品規格。</p>
<p>第二階段（<span>Concept Design-E</span>）：工程設計師根據產品規格快速制定初步佈局。 他們通常使用以前開發的產品的數據。 完成後，他們將初步佈局作為<span>3D CAD</span>數據發送給工業設計師。 這是工業設計過程的起點。 工業設計人員將其用作開發外觀的輸入，而工程設計人員則尋求系統性能的解決方案並繼續完善佈局。 隨著內部佈局和外部形式的同步發展，兩個團隊密切互動並討論分歧或衝突的任何方面，並反復交換反饋以進行修改。 最終，當設計草圖發展為確定的外觀形式時，初步佈局成為確定的佈局。 此階段的結果是確定的佈局，反映了所設計產品的最終尺寸。</p>
<p><span> </span><span>2.5</span>階段（<span>Concept Design-I</span>）：此過程遠非一個獨立的後續階段，而是第二和第三階段之間的中間階段。 因此，我們將其稱為第<span>2.5</span>階段。 它從收到工程設計人員的初步佈局開始，並與<span>Concept Design-E</span>同時進行。 工業設計師檢查內部佈局並以匹配的外部形式進行覆蓋。 他們進行構思草圖，<span>3D CAD</span>建模，渲染，設計評估會議以及模擬選擇活動，以決定外觀模板的設計。 工程設計人員不斷對外觀進行建議和評估。 這樣，通過相互關聯的<span>Concept Design-I</span>和<span>Concept Design-E</span>，外觀形式和佈局便逐漸發展。</p>
<p></p>
<p></p>
<p><span>2.4</span>第<span>4</span>類：工業設計師跟工程設計師協同過程第<span>4</span>類不是官方提議，而是各個設計師在早期階段所做的努力。 在許多情況下，參與開發陣容模型的工程設計師往往會拒絕工業設計提出的新穎設計概念。</p>
<p>為了實現這些概念，工業設計師與自由職業者進行合作。因此，此過程可以繼續處理被拒絕的新穎設計概念。 此外，工業設計師和工程設計人員也進行了協同努力。 與傳統的分離方法不同，它們以集成方式處理設計概念，同時考慮了許多設計變量。 此過程的詳細階段如下）：</p>
<p><img alt="" height="341" src="/images/第四張.png" width="602"/></p>
<p>第一階段（概念產出）：如上圖所示，工業設計師獨立地構思新設計。 他們大都是根據儘管有創新性但仍未進行項目的設計思想來構建它。</p>
<p>第二階段（概念設計）：此階段始於工業設計師尋找可以與他們合作的工程設計師。 當工程設計師同意加入工業設計師以實施設計概念時，他們將在整個階段中緊密合作。 工程設計師為工業設計師提供了最先進的技術，以增強設計理念。內部佈局的第一級是根據要開發的外部形狀開發的。 該階段的結果是有關外觀和內部佈局的<span>3D CAD</span>數據。</p>
<p>第三階段（規劃產品）：產品計劃團隊通過設計評估會議來決定設計的商業化。 然後，產品計劃團隊定義設計的目標市場。 從這個階段開始，負責開發陣容模型的工程設計人員就參與其中。</p>
<p>第四階段（細節設計，測試跟生產<span>/</span>追蹤）：該階段的過程與類型<span>1</span>、<span>2</span>和<span>3</span>的過程沒有太大不同。</p>
<p>現有的產品開發環境使工程設計人員趨於保守。消費電子領域的大多數開發項目都是緊迫的。公司通常會在計劃中設定產品發布日。因此，設計人員將按照時間軸執行所有任務和事件。根據訪談數據，參與此類項目的工程設計師傾向於拒絕工業設計師提出的新穎設計概念，因為他們認為他們無法確保其概念的工作能夠在選定的時間內通過性能和可靠性測試 。測試失敗將直接影響公司的產品開發路線圖以及工程設計師評估時的年度績效。</p>
<p>這似乎使他們保守地選擇和評估設計概念。因此，對於直接參與按時間順序進入市場的項目的設計師來說，此過程幾乎不可用。相反，例如，從時間表到市場相對寬鬆的工程師設計人員，那些參與為未來產品開發先進技術的人員，將對新穎的設計理念更加開放。此外，更重要的是，似乎更願意與其他專家合作進行設計的設計師傾向於執行此過程。</p>
<p>對於<span>D</span>公司，採用這種工藝的新產品在<span>Type 4</span>方面取得了巨大的市場成功。 但是，在我們的採訪中沒有報告更多將這一過程積極應用於後續項目的案例。 儘管如此，有趣的是<span>D</span>公司還是從先進技術開發團隊派遣了幾名工程設計師到工業設計團隊的相鄰辦公室。 這啟用了協同處理案例。 高層管理人員故意讓他們動手，以使他們立即為工業設計師提供必要的技術支持，以防止工業設計師提出不切實際的設計概念。 這似乎激發了雙方更加親密，從而營造了合作的氣氛。 這將增加新興的集成設計流程的可能性。</p>
<h2>Assignment3</h2>
<p>範例一<span>:</span>使馬達每轉的脈衝數透過正交增加。</p>
<p>負載是一小磁盤，要對它的位置進行速度控制，磁盤的直徑等於0.06 m，質量等於0.050 Kg。</p>
<p><img alt="" height="383" src="/images/0512-1.png" width="506"/></p>
<p><span>L293D: </span>雙<span> H </span>橋直流馬達驅動<span> IC</span></p>
<p>dsPIC30F4011:某種晶片</p>
<p><span>voltage regulator:</span>穩壓器</p>
<p><img alt="" height="171" src="/images/0512-2.png" width="194"/></p>
<p>於第一實驗求得增益<span>k</span>，然後使用該增益來計算可用於計算恆定時間τ的穩態值。</p>
<p>要設計一個控制器，我們要指定其功能。</p>
<p>對於瞬態，我們希望負載的穩定時間小於<span>5%</span>或等於<span>3</span>τ<span>/ 5</span>，而過衝則小於或等於<span>5</span>％。</p>
<p>也可以直接在離散時間內進行所有設計。 在本示例的其餘部分中，我們將選擇此方法。</p>
<p><img alt="" height="664" src="/images/0512-3.png" width="526"/></p>
<p>根據系統傳遞函數的表達式以及所需的性能，我們至少需要一個比例積分器（<span>PI</span>）控制器。該控制器的傳遞函數由下式給出：</p>
<p><img alt="" height="56" src="/images/0512-4.png" width="134"/></p>
<p>其中<span>KP</span>和<span>KI</span>是要確定的數值，以迫使負載具有我們施加的性能。</p>
<p>使用零階保持 (Zero-order hold)和Z -transform表，我們得到：</p>
<p><img alt="" height="131" src="/images/0512-5.png" width="243"/></p>
<p>對於控制器，使用梯形離散化，我們得到：</p>
<p><img alt="" height="102" src="/images/0512-6.png" width="269"/></p>
<p>將分子和分母除以<span>z</span>並回到時間，我們得到：</p>
<p><img alt="" height="45" src="/images/0512-7.png" width="433"/></p>
<p>結合執行器及其負載和控制器之一的傳遞函數，我們得到以下閉環傳遞函數：<img alt="" height="68" src="/images/0512-8.png" width="596"/></p>
<p>現在使用期望的性能，很容易得出結論，主導極點是</p>
<p><img alt="" height="52" src="/images/0512-9.png" width="215"/></p>
<p>其中ζ和ω<span>n</span>分別代表我們系統控制閉環的阻尼比和固有頻率。 根據控制理論，眾所周知，過衝<span>d</span>％和<span>5</span>％的建立時間<span>ts</span>由下式給出：</p>
<p><img alt="" height="87" src="/images/0512-10.png" width="149"/></p>
<p>使用我們的表演和這些表達，我們得出以下結論：</p>
<p><img alt="" height="80" src="/images/0512-11.png" width="213"/></p>
<p>它具有以下主要優勢：</p>
<p><span>s1,2 = −78.2216 ± 78.2452 j</span></p>
<p>使用<span>Z</span>等於<span>e</span>的<span>ts</span>次方並使用<span>t=</span>τ<span>/10=0.0064</span>，我們在<span>Z</span>域中獲得以下主導極點：</p>
<p><span>z1,2 = 0.5317 ± 0.2910 j</span></p>
<p>對於這些極點，我們具有以下特徵方程式：</p>
<p><img alt="" height="47" src="/images/0512-12.png" width="367"/></p>
<p>現在使用極點代入，我們得到：</p>
<p><span>1 + C(z)G(z) = Δd</span></p>
<p>這意味著：</p>
<p><img alt="" height="116" src="/images/0512-13.png" width="166"/></p>
<p>使用<span>K</span>，<span>T</span>和τ的值，我們得到增益<span>KP</span>和<span>KI</span>的以下表達式：</p>
<p><span>KP = 0.1480</span></p>
<p><span>KI = 10.1951</span></p>
<p>備註<span>11.2.1</span>在這種情況下，必須謹慎，因為我們不在乎傳遞函數零的位置，因此在實現此控制器時可能會有些意外。 顯然，我們將獲得的性能（穩定時間和超調）將取決於零的位置。有關此問題的更多詳細信息，請向讀者介紹<span>Boukas</span></p>
<p>為了實現此<span>PI</span>控制算法並確保所需的性能，我們將使用<span>Microship1</span>的微控制器。 這種選擇是由於我們在此類微控制器方面的經驗所致。 讀者可以記住，其他製造商的其他任何微控制器都可以做些小改動。 在本示例中，我們將使用<span>Microhip</span>的單片機<span>dsPIC30F4011</span>。</p>
<p>我們實現的代碼使用<span>C</span>語言編寫。 採用這種語言是因為其簡單性。 該實現具有以下結構：</p>
<pre class="brush:csharp;auto-links:false;toolbar:false" contenteditable="false">//
// Put here the include
//
#include "p30F4011.h" // proc specific header
// Define a struct
//
typedef struct {
// PI Gains
float K_P; // Propotional gain
float K_I; // Integral gain
//
// PI Constants
//
float Const1_pid; // KP + T KI/2
float Const2_pid; // -KP + T KI/2
float Reference; // speed reference
//
// System variables
//
float y_k; // y_m[k] -&gt; measured output at time k
float u_k; // u[k] -&gt; output at time k
float e_k; // e[k] -&gt; error at time k
//
// System past variables
//
float u_prec; // u[k-1] -&gt; output at time k-1
float e_prec; // e[k-1] -&gt; error at time k-1
}PIStruct;
PIStruct thePI;
thePI.Const1= thePI.K_P+T*thePI.K_I/2;
thePI.Const2=-thePI.K_P+T*thePI.K_I/2;
thePI.Reference=600;
//
// Functions
//
float ReadSpeed(void);
float ComputeControl(void);
float SendControl(void);
//
// Interrupt program here using Timer 1 (overflow of counter Timer 1)
//
void __ISR _T1Interrupt(void) // interrupt routine code
{
// Interrupt Service Routine code goes here
float Position_error;
//
// Read speed
//
thePI.y_m=ReadSpeed();
thePI.e_k= thePI.Reference-thePI.y_m;
//
// Compute the control
//
ComputeContrl();
//
// Send control
//
SendControl();
IFS0bits.T1IF=0; // Disable the interrupt
}
int main ( void ) // start of main application code
{
// Application code goes here
int i;
// Initialize the variables Reference and ThePID.y_m (it can be read
from inputs) Reference = 0x8000; // Hexadecimal number
(0b... Binary number) ThePID = 0x8000;
// Initialize the registers
TRISC=0x9fff; // RC13 and RC14 (pins 15 and 16) are configured as outputs
IEC0bits.T1IE=1; // Enable the interrupt on Timer 1
// Indefinite loop
while (1)
{
}
return 0
}
% ReadSpeed function
int ReadSpeed (void)
{
}
% ComputeControl function
int ComputeControl (void)
{
thePI.u_k=thePI.u_prec+thePI.Const1*thePI.e_k+thePI.Const2*thePI.e_prec;
}
% SendControl function
int Send Control (void)
{
sendControl()
//
// Update past data
//
thePI.u_prec=thePI.u_k;
ThePI.e_prec=thePI.e_k;
}
</pre>
<p>從該結構可以看出，首先我們注意到系統將進入循環，並在每次中斷時調用函數：</p>
<ul>
<li><span> ReadSpeed;</span></li>
<li><span> ComputeControl;</span></li>
<li><span> SendControl;</span></li>
</ul>
<p>並採取適當的措施。</p>
<p><span>ReadSpeed</span>函數在每個採樣時間返回加載速度，該速度將由<span>ComputeControl</span>函數使用。<span> SendControl</span>功能通過<span>L293D</span>芯片將適當的電壓發送到執行器。</p>
<p>使用編譯器<span>HighTec C</span>獲取十六進制代碼，並使用<span>PicKit-2</span>將文件上傳到微控制器的內存中。 有關如何獲取十六進制代碼的更多詳細信息，我們邀請讀者閱讀編譯器<span>HighTec C</span>或<span>Microchip</span>的編譯器<span>C30</span>的手冊。</p>
<p>但是這種情況是不實用的</p>
<p><span>Position Control of the dc Motor Kit</span></p>
<p>我們專注於負載位置控制。 遵循與上一節中開發的負載速度控制類似的步驟，我們首先需要選擇我們希望系統具有的理想性能。 進行以下表演：</p>
<p>系統穩定在閉環狀態；</p>
<p>建立時間<span>ts</span>為<span>2</span>％等於我們可以擁有的最佳時間</p>
<p><span>Overshoot(</span>過衝<span>)</span>等於<span>5</span>％</p>
<p>穩態<span> (Steady state)</span>等於<span>0</span>在功能輸入時</p>
<p>使用性能和傳遞函數，很容易得出結論，比例控制器<span>KP</span>足以滿足這些性能。</p>
<p>在此示例中，我們將使用連續時間方法進行控制器的設計。 在上一章的基礎上，我們的系統模型如下：</p>
<p><img alt="" height="48" src="/images/0513-1.png" width="132"/></p>
<p>其中<span>K</span>和τ取與速度控制相同的值。 讓傳輸控制器由以下方式給出：</p>
<p><span>C(s) = KP</span></p>
<p>使用這些表達式，閉環傳遞函數由下式給出：</p>
<p><img alt="" height="102" src="/images/0513-2.png" width="173"/></p>
<p>由於系統類型為<span>1</span>，因此使用比例控制器輸入的階躍函數的誤差等於零。</p>
<p>根據規範，得出以下複雜的極點：</p>
<p><img alt="" height="39" src="/images/0513-3.png" width="208"/></p>
<p>將完成這項工作，相應的特徵方程式如下：</p>
<p><img alt="" height="31" src="/images/0513-4.png" width="163"/></p>
<p>與閉環系統之一等效，我們得到：</p>
<p><img alt="" height="92" src="/images/0513-5.png" width="130"/></p>
<p>為了確定最佳穩定時間<span>ts</span>為<span>2</span>％，請注意，我們有：</p>
<p><span>Ts = 4/</span>ζ<span>wn</span></p>
<p>現在是</p>
<p>ζ<span>Wn = 1/2τ</span></p>
<p>我們獲得：</p>
<p>因此，使用此控制器可以在％<span>2</span>處獲得的最佳建立時間是系統恆定時間的<span>8</span>倍。 小於可獲得的任何值。 實際上，如果我們在改變<span>KP</span>時關注閉環系統的根源，這是微不足道的。 這由下圖給出。 為了固定控制器的增益，所需極點<span>s1,2 = -7.5</span>±<span>j</span>，我們使用該圖並選擇一個ζ<span>= 0.707</span>。 得出<span>KP = 0.1471</span>。</p>
<p><span> </span><img alt="" height="462" src="/images/0513-6.png" width="527"/></p>
<p>使用該控制器，幅度等於<span>30</span>度的階躍函數的時間響應由下表示，從中我們可以得出結論，所設計的控制器以％<span>2</span>的穩定時間等於<span>0.5115 s</span>滿足了所有期望的性能。 但是，如果我們實現此控制器，則實際情況將與仿真有所不同，因為變速箱的齒隙並未包含在所使用的模型中，因此實時結果將有所不同，誤差永遠不會為零。 為了克服這個問題，我們可以使用比例和微分控制器，它可以在％<span>2</span>處提供更好的建立時間。 讓該控制器的傳遞函數由下式給出：</p>
<p><span>C(s) = KP + KD s</span></p>
<p>備註11.3.1必須注意，比例和微分控制器的使用將在閉環傳遞中引入零，如果放置得當，則可以縮短建立時間。 根據其位置，過沖和建立時間將受到影響。 有關此問題的更多詳細信息</p>
<p><img alt="" height="441" src="/images/0513-7.png" width="516"/></p>
<p>使用該控制器，閉環傳遞函數由下式給出：</p>
<p><img alt="" height="92" src="/images/0513-8.png" width="130"/></p>
<p>在這種情況下，我們有兩個未知變量<span>KP</span>和<span>KD</span>以及兩個唯一確定增益的代數方程。 它們的表達式如下：</p>
<p><img alt="" height="90" src="/images/0513-9.png" width="115"/></p>
<p>現在，使用期望的性能，我們得出與之前類似的結論，即等於等於<span>30</span>度的幅度階躍函數的輸入的穩態誤差等於零，並且與過衝等於％<span>5</span>的阻尼比ζ等於<span> 0.707</span>。 我們可以將其固定為系統時間常數的一部分的穩定時間<span>ts</span>在％<span>2</span>處給出：</p>
<p><img alt="" height="49" src="/images/0513-10.png" width="90"/></p>
<p>現在，如果將穩定時間固定為<span>3</span>τ，我們將得到：</p>
<p><span>Wn = 29.4985</span></p>
<p>使用這些值，我們可以得到以下控制器增益值：</p>
<p><span>Kp = 1.1374</span></p>
<p><span>Kd = 0.0545.</span></p>
<p>它給出了以下複雜的極點：</p>
<p><span>s1,2 = −28.6763 ± 6.9163 j.</span></p>
<p>零為：</p>
<p><span>z = −20.8618.</span></p>
<p>使用該控制器，幅度等於<span>30</span>度的輸入的時間響應如圖<span>11.5</span>所示。 從該圖可以看出，過沖和建立時間少於使用比例控制器獲得的過沖和建立時間。</p>
<p>要實現比例控制器或比例控制器和微分控制器，我們需要獲得控制律的遞推方程。 為此，我們需要使用前面介紹的不同方法離散化控制器的傳遞函數。</p>
<p>讓我們使用梯形方法替換<span>s</span>成<span>2/t*z-1/z+1</span>，這給出了<span>:</span></p>
<p><span>C</span>（<span>z</span>）<span>= Kp</span>對於比例控制器</p>
<p><span>C(z) = KP + KD 2/t*z-1/z+1</span>用於比例和微分控制器</p>
<p>如果我們通過控制分別表示<span>u</span>（<span>k</span>）和<span>e</span>（<span>k</span>）以及在瞬時<span>kT</span>處參考和輸出之間的誤差，我們將得到以下表達式：</p>
<p><span>1.</span>比例</p>
<p><img alt="" height="49" src="/images/0513-11.png" width="199"/></p>
<p><img alt="" height="507" src="/images/0513-12.png" width="582"/></p>
<p>2.用於比例和微分控制器</p>
<p><img alt="" height="93" src="/images/0513-13.png" width="729"/></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Main program %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
main
% Data
% Variables
% While loop
while (1)
do
ReadSpeed;
ComputeControl;
SendControl;
end;
% ReadSpeed function
% ComputeControl function
% SendControl function
</pre>
<p>現在讓我們使用此示例的狀態空間表示，並設計一個狀態反饋控制器，以保證所需的性能。 對於這種情況，我們將首先假設完全訪問狀態，其次通過假設我們只能訪問該職位來放寬此假設。 像我們之前所做的那樣，我們可以連續進行，也可以不連續進行。</p>
<p>先前我們建立了該系統的狀態空間描述，其描述為：</p>
<p><img alt="" height="108" src="/images/0513-14.png" width="375"/></p>
<p>其中<span>x</span>（<span>t</span>）∈<span>R2</span>（<span>x1</span>（<span>t</span>）<span>=θ</span>（<span>t</span>）和<span>x2</span>（<span>t</span>）<span>=θ̇</span>（<span>t</span>）），<span>u</span>（<span>t</span>）∈<span>R</span>（施加電壓）。</p>
<p>從穩定時間為％<span>2</span>等於<span>3</span>τ的期望性能中，我們得到與以前相同的主導極點，因此具有相同的特性方程式，</p>
<p><img alt="" height="45" src="/images/0513-15.png" width="703"/></p>
<p>使用控制器表達式，閉環特性方程由下式給出：</p>
<p><span>det (sI − A + BK) = 0</span></p>
<p>通過均衡這兩個方程式，我們可以得到以下收益：</p>
<p><span>K1 = 1.1146</span></p>
<p><span>K2 = 0.0326</span></p>
<p>使用該控制器，幅度等於<span>30</span>度的輸入的時間響應如下圖<span>11-6</span>所示。 從該圖可以看出，超調和建立時間就是我們想要的。 重要的是要注意穩態狀態下錯誤的存在。 如果在循環中添加一個積分動作，則可以消除此錯誤。</p>
<p>對於第二種情況，由於我們無法獲得負載速度，因此我們可以從位置計算負載速度，也可以使用觀察者來估算系統狀態。 如前所述，我們用於觀察者設計的極點應該比控制器設計中使用的極點更快。</p>
<p>選擇以下極點（s1,2，為控制器設計中所用實數的四倍）：</p>
<p><img alt="" height="115" src="/images/0513-16.png" width="379"/></p>
<p><img alt="" height="478" src="/images/0513-17.png" width="553"/></p>
<p>根據觀察<span>:</span></p>
<p><span>L1 = 151.2</span></p>
<p><span>L2 = 5029.4</span></p>
<p>控制器的增益與對狀態向量的完全情況相同。</p>
<p>在下面的<span>Matlab</span>中，我們同時提供控制器和觀察者的設計，並進行仿真，以顯示系統和觀察者的狀態相對於時間的行為。</p>
<p><span>clear all</span></p>
<p><span>%data</span></p>
<p><span>tau=0.064</span></p>
<p><span>k=48.9</span></p>
<p><span>A = [0 1;0 -1/tau];</span></p>
<p><span>B = [0 ; k/tau];</span></p>
<p><span>C = [1 0];</span></p>
<p><span>D = 0;</span></p>
<p><span>% controller design</span></p>
<p><span>K = acker(A,B,[-3+3*j -3-3*j]);</span></p>
<p><span>L = acker(A’,C’,[-12+3*j -12-3*j])’;</span></p>
<p><span>% Simualation data</span></p>
<p><span>Ts = 0.01;</span></p>
<p><span>x0 = [1 ; 1];</span></p>
<p><span>z0 = [1.1 ; 0.9];</span></p>
<p><span>Tf = 2; %final time</span></p>
<p><span>%augmented system</span></p>
<p><span>Ah = [A -B*K;</span></p>
<p><span>L*C A-B*K-L*C];</span></p>
<p><span>Bh = zeros(size(Ah,1),1);</span></p>
<p><span>Ch = [C D*K];</span></p>
<p><span>Dh = zeros(size(Ch,1),1);</span></p>
<p><span>xh0 = [x0 ; z0];</span></p>
<p><span>t=0:Ts:Tf;</span></p>
<p><span>u = zeros(size(t));</span></p>
<p><span>m = ss(Ah,Bh,Ch,Dh);</span></p>
<p><span>%simulation</span></p>
<p><span>[y,t,x] = lsim(m,u,t,xh0);</span></p>
<p><span>%plotting</span></p>
<p><span>figure;</span></p>
<p><span>plot(t,y);</span></p>
<p><span>title(’Output’);</span></p>
<p><span>xlabel(’Time in sec’)</span></p>
<p><span>ylabel(’Output’)</span></p>
<p><span>grid</span></p>
<p><span>figure;</span></p>
<p><span>plot(t,x(:,1:size(A,1)));</span></p>
<p><span>title(’States of the system’);</span></p>
<p><span>xlabel(’Time in sec’)</span></p>
<p><span>ylabel(’System states’)</span></p>
<p><span>grid</span></p>
<p><span>figure;</span></p>
<p><span>plot(t,x(:,size(A,1)+1:end));</span></p>
<p><span>title(’states of the observer’);</span></p>
<p><span>xlabel(’Time in sec’)</span></p>
<p><span>ylabel(’Observer states’)</span></p>
<p>grid</p>
<p><img alt="" height="456" src="/images/0513-18.png" width="528"/></p>
<p>我們還可以使用線性二次調節器設計狀態反饋控制器。 實際上，如果我們為成本函數選擇以下矩陣：</p>
<p><img alt="" height="105" src="/images/0513-19.png" width="143"/></p>
<p>使用這些矩陣和<span>Matlab</span>函數<span>lqr</span>，我們得到：</p>
<p><span>K = [0.3162 0.6875]</span></p>
<p>我們還可以使用魯棒控制部分的結果設計狀態反饋控制器。 由於系統沒有不確定性，也沒有外部干擾，所以我們可以為名義動態設計一個狀態反饋控制器。 使用系統數據和<span>Maltlab</span>，我們得到：</p>
<p><img alt="" height="118" src="/images/0513-20.png" width="265"/></p>
<p><img alt="" height="526" src="/images/0513-21.png" width="585"/></p>
<p>給出了相應的控制器增益：</p>
<p><span>K =[−0.0017 0.0193 ]</span></p>
<p>備註11.3.3由於我們有直流電動機套件的連續時間模型，因此我們用它來設計控制器增益。 在這種情況下，我們解決了以下LMI：</p>
<p><img alt="" height="46" src="/images/0513-22.png" width="289"/></p>
<p>增益<span>K</span>由下式給出：</p>
<p><img alt="" height="39" src="/images/0513-23.png" width="106"/></p>